/*
 * MikroChat version 2.0.0
 * Bundle generated on 2026-02-06T09:51:05.845Z
 */
(() => {
  var xa = Object.defineProperty;
  var f = (e, t) => () => (e && (t = e((e = 0))), t);
  var $ = (e, t) => {
    for (var n in t) xa(e, n, { get: t[n], enumerable: !0 });
  };
  var r,
    v = f(() => {
      r = {
        currentChannelForEdit: null,
        currentUser: null,
        currentChannelId: null,
        messageEventSource: null,
        currentMessageForReaction: null,
        currentMessageForReactionIsDM: !1,
        currentMessageForEdit: null,
        currentMessageForEditIsDM: !1,
        currentMessageForEditContent: '',
        currentMessageForEditImages: [],
        isStorageInitialized: !1,
        pendingUploads: [],
        tempIdMap: new Map(),
        messageCache: new Map(),
        unreadCounts: new Map(),
        storage: null,
        currentConversationId: null,
        conversationCache: new Map(),
        dmMessageCache: new Map(),
        dmUnreadCounts: new Map(),
        viewMode: 'channel'
      };
    });
  var Oe,
    gt,
    hn,
    ft,
    ht,
    Q,
    O,
    vn,
    yn,
    En,
    wn,
    In,
    Mn,
    vt,
    yt,
    b,
    Cn,
    Et,
    _,
    q,
    wt,
    It,
    xn,
    H,
    Sn,
    me,
    ue,
    z,
    Ln,
    k,
    kn,
    Mt,
    ee,
    Tn,
    Un,
    T,
    u,
    Qa,
    x,
    Ct,
    _e,
    te,
    qe,
    xt,
    He,
    pe,
    ze,
    ge,
    fe,
    he,
    St,
    Lt,
    Dn,
    kt,
    An,
    je,
    $n,
    ve,
    bn,
    ye,
    Rn,
    j,
    I = f(() => {
      (Oe = document.getElementById('add-email-input')),
        (gt = document.getElementById('add-user-btn')),
        (hn = document.getElementById('add-channel-btn')),
        (ft = document.getElementById('app-container')),
        (ht = document.getElementById('auth-container')),
        (Q = document.getElementById('channel-name')),
        (O = document.getElementById('channels-list')),
        (vn = document.getElementById('close-channel-modal')),
        (yn = document.getElementById('close-edit-channel-modal')),
        (En = document.getElementById('close-edit-modal')),
        (wn = document.getElementById('close-reaction-modal')),
        (In = document.getElementById('close-image-preview')),
        (Mn = document.getElementById('close-server-settings-modal')),
        (vt = document.getElementById('create-channel-modal')),
        (yt = document.getElementById('create-channel-submit')),
        (b = document.getElementById('current-channel-name')),
        (Cn = document.getElementById('delete-channel-btn')),
        (Et = document.getElementById('edit-channel-modal')),
        (_ = document.getElementById('edit-channel-name')),
        (q = document.getElementById('edit-message-input')),
        (wt = document.getElementById('edit-message-modal')),
        (It = document.getElementById('edit-message-submit')),
        (xn = document.getElementById('auth-form-email')),
        (H = document.getElementById('auth-email')),
        (Sn = document.getElementById('reaction-picker')),
        (me = document.getElementById('reaction-picker-modal')),
        (ue = document.getElementById('auth-form-encryption')),
        (z = document.getElementById('encryption-password')),
        (Ln = document.getElementById('exit-server-btn')),
        (k = document.getElementById('image-preview-modal')),
        (kn = document.getElementById('image-upload')),
        (Mt = document.getElementById('loading')),
        (ee = document.getElementById('login-btn')),
        (Tn = document.getElementById('logout-btn')),
        (Un = document.getElementById('menu-toggle')),
        (T = document.getElementById('message-input')),
        (u = document.getElementById('messages-area')),
        (Qa = document.getElementById('password')),
        (x = document.getElementById('preview-image')),
        (Ct = document.getElementById('send-button')),
        (_e = document.getElementById('server-name')),
        (te = document.getElementById('server-name-input')),
        (qe = document.querySelector('.server-name-text')),
        (xt = document.getElementById('server-settings-modal')),
        (He = document.getElementById('sidebar')),
        (pe = document.getElementById('auth-form-text')),
        (ze = document.getElementById('theme-switch')),
        (ge = ze?.querySelector('.theme-switch-icon')),
        (fe = ze?.querySelector('.theme-switch-label')),
        (he = document.getElementById('toast')),
        (St = document.getElementById('update-channel-submit')),
        (Lt = document.getElementById('update-server-name-btn')),
        (Dn = document.getElementById('user-avatar')),
        (kt = document.getElementById('user-dropdown')),
        (An = document.getElementById('user-menu')),
        (je = document.getElementById('users-list')),
        ($n = document.getElementById('user-name')),
        (ve = document.getElementById('dm-list')),
        (bn = document.getElementById('start-dm-btn')),
        (ye = document.getElementById('start-dm-modal')),
        (Rn = document.getElementById('close-start-dm-modal')),
        (j = document.getElementById('dm-user-list'));
    });
  var W,
    R,
    U = f(() => {
      (W = 'http://localhost:3000'), (R = '$J2Ek<wp5Wsp+x!FsGb[');
      console.table([
        { flag: 'AUTH_MODE', setting: 'dev' },
        { flag: 'API_BASE_URL', setting: W },
        { flag: 'DEFAULT_PASSWORD', setting: R },
        { flag: 'ENABLE_USER_SPECIFIC_ENCRYPTION', setting: !1 },
        { flag: 'MAX_CONTENT_LENGTH', setting: 1e3 }
      ]),
        console.log(`Has ${window.localStorage.length} items in localStorage`);
    });
  function N(e) {
    return e
      ? e
          .split(' ')
          .map((t) => t.charAt(0))
          .join('')
          .toUpperCase()
      : '?';
  }
  function Tt(e) {
    return (e instanceof Date ? e : new Date(e)).toLocaleDateString();
  }
  function we(e) {
    return (e instanceof Date ? e : new Date(e)).toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit'
    });
  }
  function Nn(e) {
    if (
      !e ||
      typeof e != 'string' ||
      ((e = e.trim()), e === '') ||
      e.includes(' ') ||
      e.includes('..')
    )
      return !1;
    const t = e.indexOf('@');
    if (t === -1) return !1;
    const n = e.slice(0, t),
      a = e.slice(t + 1);
    if (
      n.length === 0 ||
      a.length === 0 ||
      !/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+$/.test(n)
    )
      return !1;
    const s = a.split('.');
    if (s.length < 2) return !1;
    const i = s[s.length - 1];
    if (i.length < 2 || !/^[a-zA-Z]+$/.test(i)) return !1;
    for (const c of s)
      if (
        c.length === 0 ||
        !/^[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(c)
      )
        return !1;
    return !0;
  }
  function Bn(e) {
    return typeof e != 'string'
      ? ''
      : e
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
  }
  function We(e) {
    if (!e) return '';
    let t = e;
    return (
      (t = t.replace(/```([\s\S]*?)```/g, function (n, a) {
        return `<pre><code>${a.trim()}</code></pre>`;
      })),
      (t = t.replace(/(\*\*|__)(.*?)\1/g, '<strong>$2</strong>')),
      (t = t.replace(/(\*|_)(?!\*|_)(.*?)\1/g, '<em>$2</em>')),
      (t = t.replace(/(?:^|\n)((?:(?:- |\* ).*(?:\n|$))+)/gm, function (n, a) {
        let o = a.split(/\n(?=(?:- |\* ))/),
          s = '<ul>';
        for (const i of o)
          if (i.trim()) {
            const c = i.replace(/^(?:- |\* )/, '').trim();
            s += `<li>${c}</li>`;
          }
        return (s += '</ul>'), s;
      })),
      (t = t.replace(/(?:^|\n)((?:(?:\d+\. ).*(?:\n|$))+)/gm, function (n, a) {
        let o = a.split(/\n(?=(?:\d+\. ))/),
          s = '<ol>';
        for (const i of o)
          if (i.trim()) {
            const c = i.replace(/^\d+\. /, '').trim();
            s += `<li>${c}</li>`;
          }
        return (s += '</ol>'), s;
      })),
      t
    );
  }
  function Ee(e) {
    return Array.from(document.querySelectorAll('.message')).find(
      (n) => n.dataset.id === e
    );
  }
  function Ge(e, t) {
    const n = Ut(e);
    return n
      ? Array.from(n.querySelectorAll('.user-reacted'))
          .map((o) => o.dataset.reaction)
          .some((o) => o === t)
      : !1;
  }
  function Ut(e) {
    let t = null;
    if (((t = Ee(e)), !t)) {
      for (const [a, o] of r.tempIdMap.entries())
        if (o === e && ((t = Ee(a)), t)) break;
    }
    if (!t) return null;
    const n = t.querySelector('.message-reactions');
    return n || null;
  }
  var B = f(() => {
    v();
  });
  async function Ce(e) {
    const t = e || R;
    console.log('Initializing storage with password', t);
    try {
      if (1)
        return (
          console.log('Setting up default encryption...', t),
          await Ie(t, !0),
          !0
        );
      if (Dt())
        try {
          return await Ie(t, !1), (await r.storage.getItem(Me)) === 'true';
        } catch (a) {
          return (
            console.error(
              'Failed to decrypt existing data with provided password:',
              a
            ),
            !1
          );
        }
      else
        return (
          console.log('Setting up custom encryption...', t),
          await Ie(t, !0),
          await r.storage.setItem(Me, 'true'),
          !0
        );
    } catch (n) {
      return console.error('Failed to initialize storage:', n), !1;
    }
  }
  async function Ie(e, t = !0) {
    const n = await new MikroSafe(e);
    (r.storage = n),
      (r.isStorageInitialized = !0),
      t && (await r.storage.setItem(Me, 'true'));
  }
  function Dt() {
    const e = Object.keys(localStorage),
      t = e.includes(Me),
      n = e.includes('token') || e.includes('accessToken');
    return t && n;
  }
  async function Fn(e) {
    try {
      return (await Ce(e)) ? (await r.storage.getItem(Me)) === 'true' : !1;
    } catch (t) {
      return console.error('Error verifying encryption password:', t), !1;
    }
  }
  var Me,
    Ye = f(() => {
      v();
      U();
      Me = '_storage_initialized_';
    });
  function ne() {
    const e = new URLSearchParams(window.location.search),
      t = e.get('email'),
      n = e.get('token');
    return { emailParam: t, tokenParam: n };
  }
  var At = f(() => {});
  function G() {
    const { emailParam: e, tokenParam: t } = ne();
    return e && t;
  }
  async function Pn() {
    try {
      const { emailParam: e, tokenParam: t } = ne();
      if (!e || !t) return !1;
      const n = await On({ email: e, token: t }),
        { accessToken: a, refreshToken: o } = n;
      return (
        await r.storage.setItem('accessToken', a),
        await r.storage.setItem('refreshToken', o),
        !0
      );
    } catch (e) {
      return console.log('Magic link verification error:', e), !1;
    }
  }
  var Je = f(() => {
    v();
    At();
    D();
  });
  async function Ke(e) {
    e
      ? (document.body.classList.remove('light-mode'),
        ge && (ge.textContent = '\u{1F319}'),
        fe && (fe.textContent = 'Dark Mode'))
      : (document.body.classList.add('light-mode'),
        ge && (ge.textContent = '\u2600\uFE0F'),
        fe && (fe.textContent = 'Light Mode')),
      await r.storage.setItem('darkMode', e ? 'true' : 'false');
  }
  var $t = f(() => {
    v();
    I();
  });
  async function Xe() {
    try {
      const e = await p('/users', 'GET');
      if (((je.innerHTML = ''), e.users && e.users.length > 0)) {
        const t = [...e.users].sort((n, a) =>
          n.id === r.currentUser.id ? -1 : a.id === r.currentUser.id ? 1 : 0
        );
        for (const n of t) {
          const a = document.createElement('div');
          (a.className = 'user-item'),
            (a.dataset.id = n.id),
            (a.innerHTML = `
          <div class="user-avatar">${N(n.userName || n.email.split('@')[0])}</div>
          <div class="user-info">
            <div class="user-email">${n.email}</div>
            <div class="user-role ${n.isAdmin ? 'admin-role' : 'user-role'}">${n.isAdmin ? 'Admin' : 'User'}</div>
            <div class="user-created">Added ${we(new Date(n.createdAt))}</div>
          </div>
          ${
            n.id !== r.currentUser.id
              ? `
            <div class="user-actions">
              <button class="remove-user" title="Remove User">\u2715</button>
            </div>
          `
              : ''
          }
        `);
          const o = a.querySelector('.remove-user');
          o && o.addEventListener('click', () => Sa(n.id, n.email)),
            je.appendChild(a);
        }
      } else je.innerHTML = '<div class="empty-list">No users added yet</div>';
    } catch (e) {
      console.error('Error loading users:', e),
        d('Failed to load users', 'error');
    }
  }
  async function _n(e, t) {
    try {
      L();
      const n = await p('/users/add', 'POST', { email: e, role: t });
      h(), n.success && (d(`User ${e} added successfully!`), Xe());
    } catch (n) {
      h(), d(n.message || 'Failed to add user', 'error');
    }
  }
  async function Sa(e, t) {
    if (confirm(`Are you sure you want to remove user ${t}?`))
      try {
        L(),
          await p(`/users/${e}`, 'DELETE'),
          h(),
          d(`User ${t} has been removed`),
          Xe();
      } catch (n) {
        h(), d(n.message || 'Failed to remove user', 'error');
      }
  }
  var bt = f(() => {
    v();
    I();
    w();
    y();
    B();
  });
  var qn = {};
  $(qn, {
    hideServerSettingsModal: () => Ze,
    loadServerName: () => La,
    openServerSettingsModal: () => Rt,
    updateServerName: () => Nt
  });
  function Rt() {
    const e = _e.textContent.trim().replace(/\s+/g, ' ');
    (te.value = e), xt.classList.add('active'), te.focus(), Xe();
  }
  function Ze() {
    xt.classList.remove('active');
  }
  async function Nt(e) {
    try {
      L();
      const t = await p('/server/settings', 'PUT', { name: e });
      return (
        (qe.textContent = e),
        await r.storage.setItem('serverName', e),
        Ze(),
        d('Server name updated successfully'),
        h(),
        t
      );
    } catch (t) {
      throw (h(), d(t.message || 'Failed to update server name', 'error'), t);
    }
  }
  async function La() {
    try {
      const t = await p('/server/settings', 'GET');
      if (t?.name) {
        (qe.textContent = t.name),
          await r.storage.setItem('serverName', t.name);
        return;
      }
    } catch (t) {
      console.error('Error loading server name from API:', t);
    }
    const e = await r.storage.getItem('serverName');
    e && (qe.textContent = e);
  }
  var Bt = f(() => {
    v();
    I();
    w();
    y();
    bt();
  });
  var _t = {};
  $(_t, {
    convertBlobToBase64: () => Pt,
    formatFileSize: () => Ft,
    generateFileHash: () => zn,
    handleAddImages: () => Qe,
    hashSimple: () => jn,
    openImagePreview: () => Ot,
    removePendingUpload: () => ka,
    resizeAndCompressImage: () => Hn
  });
  async function Qe(e) {
    for (const t of e) {
      if (!t.type.match('image.*')) {
        d('Only image files are supported', 'error');
        continue;
      }
      try {
        const n = await zn(t);
        if (r.pendingUploads.some((m) => m.fileHash === n)) {
          d('This image is already in your pending uploads', 'info');
          continue;
        }
        const o = await Hn(t),
          s = Date.now(),
          i = t.name.split('.').pop().toLowerCase(),
          c = `${s}.${i}`;
        o.usedOriginal
          ? d('Used original image (no compression needed)', 'info')
          : o.compressionRatio > 0
            ? d(`Image compressed by ${o.compressionRatio.toFixed(0)}%`, 'info')
            : o.compressionRatio <= 0 &&
              d(
                `Image processed (size increased by ${Math.abs(o.compressionRatio).toFixed(0)}%)`,
                'info'
              ),
          r.pendingUploads.push({
            fileName: c,
            fileHash: n,
            blob: o.blob,
            preview: URL.createObjectURL(o.blob)
          }),
          ae();
      } catch (n) {
        console.error('Error processing image:', n),
          d('Failed to process image', 'error');
      }
    }
  }
  function ka(e) {
    URL.revokeObjectURL(r.pendingUploads[e].preview),
      r.pendingUploads.splice(e, 1),
      ae();
  }
  function Hn(e) {
    return new Promise((t, n) => {
      console.log(`Original image: ${e.name}, Size: ${Ft(e.size)}`);
      const a = new FileReader();
      (a.onload = function (o) {
        const s = new Image();
        (s.onload = function () {
          let i = s.width,
            c = s.height,
            m = `${i}x${c}`,
            l = i,
            g = c,
            E = 1200;
          l > g && l > E
            ? ((g = Math.round((g * E) / l)), (l = E))
            : g > E && ((l = Math.round((l * E) / g)), (g = E));
          const C = i !== l || c !== g,
            X = document.createElement('canvas');
          (X.width = l),
            (X.height = g),
            X.getContext('2d').drawImage(s, 0, 0, l, g);
          let Ne = 0.7,
            Be = e.type,
            Fe = e.name.split('.').pop().toLowerCase();
          Fe === 'png'
            ? ((Be = 'image/png'), (Ne = 0.8))
            : Fe === 'jpg' || Fe === 'jpeg'
              ? ((Be = 'image/jpeg'), (Ne = 0.7))
              : Fe === 'webp' && ((Be = 'image/webp'), (Ne = 0.75)),
            X.toBlob(
              (Z) => {
                if (Z)
                  if (Z.size >= e.size && !C) {
                    console.log(
                      'Processed image is larger than original. Using original file instead.'
                    );
                    const Pe = {
                      blob: e,
                      originalSize: e.size,
                      newSize: e.size,
                      compressionRatio: 0,
                      originalDimensions: m,
                      newDimensions: m,
                      usedOriginal: !0
                    };
                    t(Pe);
                  } else {
                    const Pe = ((1 - Z.size / e.size) * 100).toFixed(2);
                    console.log(`Processed image: ${l}x${g} (from ${m})`),
                      console.log(`New size: ${Ft(Z.size)}, Reduction: ${Pe}%`);
                    const Ca = {
                      blob: Z,
                      originalSize: e.size,
                      newSize: Z.size,
                      compressionRatio: Number.parseFloat(Pe),
                      originalDimensions: m,
                      newDimensions: `${l}x${g}`,
                      usedOriginal: !1
                    };
                    t(Ca);
                  }
                else n(new Error('Failed to create image blob'));
              },
              Be,
              Ne
            );
        }),
          (s.onerror = function () {
            n(new Error('Failed to load image'));
          }),
          (s.src = o.target.result);
      }),
        (a.onerror = function () {
          n(new Error('Failed to read file'));
        }),
        a.readAsDataURL(e);
    });
  }
  function Ft(e) {
    return e < 1024
      ? `${e} bytes`
      : e < 1048576
        ? `${(e / 1024).toFixed(2)} KB`
        : `${(e / 1048576).toFixed(2)} MB`;
  }
  function Pt(e) {
    return new Promise((t, n) => {
      const a = new FileReader();
      (a.onloadend = () => {
        const o = a.result.split(',')[1];
        t(o);
      }),
        (a.onerror = n),
        a.readAsDataURL(e);
    });
  }
  async function zn(e) {
    return new Promise((t) => {
      const n = new FileReader();
      (n.onload = (a) => {
        const o = a.target.result,
          s = jn(o);
        t(s);
      }),
        n.readAsArrayBuffer(e);
    });
  }
  function jn(e) {
    let t = new DataView(e),
      n = 0,
      a = Math.max(1, Math.floor(e.byteLength / 1e3));
    for (let o = 0; o < e.byteLength; o += a) {
      const s = o + 3 < e.byteLength ? t.getUint32(o) : t.getUint8(o);
      (n = (n << 5) - n + s), (n |= 0);
    }
    return n.toString(16);
  }
  async function Ot(e) {
    (x.src = ''), k.classList.add('active'), (x.style.display = 'none');
    const t = document.createElement('div');
    (t.className = 'loading-spinner'),
      k.querySelector('.image-preview-container').appendChild(t),
      await M().then((n) => {
        fetch(e, { method: 'GET', headers: { Authorization: `Bearer ${n}` } })
          .then((a) => {
            if (!a.ok) throw new Error('Image fetch failed');
            return a.blob();
          })
          .then((a) => {
            const o = URL.createObjectURL(a);
            (x.src = o), (x.style.display = 'block');
            const s = k.querySelector('.loading-spinner');
            s && s.remove(), x.setAttribute('data-object-url', o);
          })
          .catch((a) => {
            console.error('Error fetching preview image:', a),
              (x.style.display = 'none'),
              (k.querySelector('.image-preview-container').innerHTML =
                '<div class="image-error">Failed to load image</div>');
          });
      });
  }
  var xe = f(() => {
    v();
    I();
    U();
    y();
    D();
  });
  var Wn = {};
  $(Wn, {
    addReaction: () => nt,
    processReactions: () => qt,
    removeReaction: () => Ht,
    updateReactionInUI: () => F
  });
  function qt(e) {
    const t = {};
    if (!e) return t;
    for (const [n, a] of Object.entries(e)) {
      if (!a) return;
      for (const o of a) t[o] || (t[o] = []), t[o].push(n);
    }
    return t;
  }
  async function nt(e, t) {
    const n = se(e);
    if (!n) {
      d('Invalid message ID', 'error');
      return;
    }
    if (!Ge(e, t))
      try {
        if (r.messageCache.has(e)) {
          const a = r.messageCache.get(e);
          a.reactions || (a.reactions = {}),
            a.reactions[t]
              ? a.reactions[t].includes(r.currentUser.id) ||
                a.reactions[t].push(r.currentUser.id)
              : (a.reactions[t] = [r.currentUser.id]),
            r.messageCache.set(e, a);
        }
        await p(`/messages/${n}/reactions`, 'POST', { reaction: t }),
          await F(e, t, !0, !1),
          me.classList.remove('active');
      } catch (a) {
        await F(e, t, !1, !1),
          d(a.message || 'Failed to add reaction', 'error');
      }
  }
  async function Ht(e, t) {
    const n = se(e);
    if (!n) {
      d('Invalid message ID', 'error');
      return;
    }
    try {
      await p(`/messages/${n}/reactions`, 'DELETE', { reaction: t }),
        await F(e, t, !1, !1);
    } catch (a) {
      await F(e, t, !0, !1),
        d(a.message || 'Failed to remove reaction', 'error');
    }
  }
  async function F(e, t, n, a = !1) {
    const o = Ta(e);
    if (!o) return;
    const s = o.querySelector(`.reaction[data-reaction="${t}"]`),
      i = et(s);
    if (a) {
      n
        ? s
          ? re(s, i + 1)
          : await oe(e, t, 1, !1)
        : s && (et(s) - 1 >= 1 ? re(s, i - 1) : s.remove());
      return;
    }
    n
      ? s
        ? (re(s, i + 1), tt(s, n))
        : await oe(e, t, 1, !0)
      : s && (i > 1 ? (re(s, i - 1), tt(s, n)) : s.remove());
  }
  function Ta(e) {
    let t = null;
    if (((t = Ee(e)), !t)) {
      for (const [a, o] of r.tempIdMap.entries())
        if (o === e && ((t = Ee(a)), t)) break;
    }
    if (!t) return;
    const n = t.querySelector('.message-reactions');
    if (n) return n;
  }
  var Se = f(() => {
    v();
    I();
    w();
    y();
    B();
    V();
  });
  var Yn = {};
  $(Yn, {
    appendDMMessage: () => Wt,
    deleteDMMessage: () => jt,
    loadDMMessagesForConversation: () => zt,
    removeDMMessageFromView: () => Vt,
    renderDMMessage: () => at,
    renderDMMessages: () => Gn,
    sendDMMessage: () => Aa,
    updateDMMessage: () => rt,
    updateDMMessageInView: () => Gt,
    uploadDMImage: () => $a
  });
  async function zt(e) {
    if (u)
      try {
        const n = (await p(`/conversations/${e}/messages`)).messages || [];
        r.dmMessageCache.set(e, n), Gn(n);
      } catch (t) {
        console.error('Failed to load DM messages:', t),
          (u.innerHTML =
            '<div class="empty-state"><div class="empty-state-icon">!</div><h3>Failed to load messages</h3></div>');
      }
  }
  function Gn(e) {
    if (!u) return;
    if (e.length === 0) {
      u.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">@</div>
        <h3>Start the conversation</h3>
        <p>Send a message to start chatting</p>
      </div>
    `;
      return;
    }
    let t = Ua(e),
      n = '';
    for (const [a, o] of Object.entries(t)) {
      n += `<div class="message-date-divider">${a}</div>`;
      for (const s of o) n += at(s);
    }
    (u.innerHTML = n), ot();
  }
  function Ua(e) {
    const t = {};
    for (const n of e) {
      const a = new Date(n.createdAt),
        o = Vn(a);
      t[o] || (t[o] = []), t[o].push(n);
    }
    return t;
  }
  function Vn(e) {
    const t = new Date(),
      n = new Date(t);
    return (
      n.setDate(n.getDate() - 1),
      e.toDateString() === t.toDateString()
        ? 'Today'
        : e.toDateString() === n.toDateString()
          ? 'Yesterday'
          : e.toLocaleDateString('en-US', {
              weekday: 'long',
              month: 'long',
              day: 'numeric'
            })
    );
  }
  function at(e) {
    let t = e.author.id === r.currentUser?.id,
      n = N(e.author.userName),
      a = Kn(e.createdAt),
      o = Jn(e.content),
      s = '';
    if (e.images && e.images.length > 0) {
      s = '<div class="message-images-container">';
      for (const m of e.images)
        s += `
        <div class="message-image-container">
          <div class="image-wrapper">
            ${t ? `<span class="remove-image-btn" data-message-id="${e.id}" data-image="${m}">&times;</span>` : ''}
            <img src="/conversations/${r.currentConversationId}/messages/image/${m}" alt="Image" class="message-image" data-image="${m}">
          </div>
        </div>
      `;
      s += '</div>';
    }
    let i = Da(e),
      c = '';
    return (
      t &&
        (c = `
      <div class="message-actions">
        <button class="message-edit" data-message-id="${e.id}" data-is-dm="true">Edit</button>
        <button class="message-delete" data-message-id="${e.id}" data-is-dm="true">Delete</button>
      </div>
    `),
      `
    <div class="message" data-message-id="${e.id}" data-is-dm="true">
      <div class="message-avatar">${n}</div>
      <div class="message-content">
        <div class="message-header">
          <span class="message-author">${e.author.userName}</span>
          <span class="message-time">${a}</span>
        </div>
        <div class="message-text">${o}</div>
        ${s}
        ${i}
        ${c}
      </div>
    </div>
  `
    );
  }
  function Da(e) {
    if (!e.reactions || Object.keys(e.reactions).length === 0)
      return `
      <div class="message-reactions">
        <div class="add-reaction" data-message-id="${e.id}">+</div>
      </div>
    `;
    const t = {},
      n = {};
    for (const [o, s] of Object.entries(e.reactions))
      for (const i of s)
        t[i] || ((t[i] = 0), (n[i] = [])), t[i]++, n[i].push(o);
    let a = '<div class="message-reactions">';
    for (const [o, s] of Object.entries(t)) {
      const i = n[o].includes(r.currentUser?.id);
      a += `
      <div class="reaction ${i ? 'user-reacted' : ''}"
           data-message-id="${e.id}"
           data-reaction="${o}">
        <span class="reaction-emoji">${o}</span>
        <span class="reaction-count">${s}</span>
      </div>
    `;
    }
    return (
      (a += `<div class="add-reaction" data-message-id="${e.id}">+</div>`),
      (a += '</div>'),
      a
    );
  }
  async function Aa(e, t = []) {
    if (r.currentConversationId)
      try {
        const n = await p(
          `/conversations/${r.currentConversationId}/messages`,
          'POST',
          { content: e, images: t }
        );
        T && ((T.value = ''), (T.style.height = 'auto')),
          (r.pendingUploads = []);
        const a = document.getElementById('pending-uploads-container'),
          o = document.getElementById('pending-uploads');
        return (
          a && (a.style.display = 'none'), o && (o.innerHTML = ''), n.message
        );
      } catch (n) {
        throw (
          (console.error('Failed to send DM:', n),
          d(n.message || 'Failed to send message', 'error'),
          n)
        );
      }
  }
  async function $a(e) {
    if (!r.currentConversationId) return null;
    try {
      const t = await ba(e.blob);
      return (
        await p(
          `/conversations/${r.currentConversationId}/messages/image`,
          'POST',
          { filename: e.name, image: t }
        )
      ).filename;
    } catch (t) {
      return (
        console.error('Failed to upload DM image:', t),
        d('Failed to upload image', 'error'),
        null
      );
    }
  }
  function ba(e) {
    return new Promise((t, n) => {
      const a = new FileReader();
      (a.onload = () => {
        const o = a.result.split(',')[1];
        t(o);
      }),
        (a.onerror = n),
        a.readAsDataURL(e);
    });
  }
  async function jt(e) {
    if (r.currentConversationId)
      try {
        await p(
          `/conversations/${r.currentConversationId}/messages/${e}`,
          'DELETE'
        ),
          d('Message deleted', 'success');
      } catch (t) {
        console.error('Failed to delete DM:', t),
          d(t.message || 'Failed to delete message', 'error');
      }
  }
  async function rt(e, t, n) {
    if (r.currentConversationId)
      try {
        const a = await p(
          `/conversations/${r.currentConversationId}/messages/${e}`,
          'PUT',
          { content: t, images: n }
        );
        return d('Message updated', 'success'), a.message;
      } catch (a) {
        throw (
          (console.error('Failed to update DM:', a),
          d(a.message || 'Failed to update message', 'error'),
          a)
        );
      }
  }
  function Wt(e) {
    if (
      !u ||
      r.viewMode !== 'dm' ||
      r.currentConversationId !== e.channelId ||
      u.querySelector(`[data-message-id="${e.id}"]`)
    )
      return;
    const n = r.dmMessageCache.get(e.channelId) || [];
    n.push(e),
      r.dmMessageCache.set(e.channelId, n),
      u.querySelector('.empty-state') && (u.innerHTML = '');
    const o = Vn(new Date()),
      s = u.querySelector('.message-date-divider:last-of-type');
    if (!s || s.textContent !== o) {
      const l = document.createElement('div');
      (l.className = 'message-date-divider'),
        (l.textContent = o),
        u.insertBefore(l, u.firstChild);
    }
    const i = at(e),
      c = document.createElement('div');
    c.innerHTML = i;
    const m = c.firstElementChild;
    u.insertBefore(m, u.firstChild), ot();
  }
  function Gt(e) {
    if (!u || r.viewMode !== 'dm' || r.currentConversationId !== e.channelId)
      return;
    const t = u.querySelector(`[data-message-id="${e.id}"]`);
    if (!t) return;
    const n = r.dmMessageCache.get(e.channelId) || [],
      a = n.findIndex((c) => c.id === e.id);
    a !== -1 && ((n[a] = e), r.dmMessageCache.set(e.channelId, n));
    const o = at(e),
      s = document.createElement('div');
    s.innerHTML = o;
    const i = s.firstElementChild;
    t.replaceWith(i);
  }
  function Vt(e, t) {
    if (!u || r.viewMode !== 'dm' || r.currentConversationId !== t) return;
    const n = u.querySelector(`[data-message-id="${e}"]`);
    n && n.remove();
    const o = (r.dmMessageCache.get(t) || []).filter((s) => s.id !== e);
    r.dmMessageCache.set(t, o),
      o.length === 0 &&
        (u.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">@</div>
        <h3>Start the conversation</h3>
        <p>Send a message to start chatting</p>
      </div>
    `);
  }
  var Le = f(() => {
    v();
    I();
    y();
    w();
    V();
    B();
  });
  async function Zn(e) {
    const t = Bn(e);
    if (!(!t.trim() && r.pendingUploads.length === 0)) {
      if (t.length > 1e3) {
        d(
          `Message too long. Your message is ${t.length} characters long and we support up to ${1e3} characters.`,
          'error'
        );
        return;
      }
      if (r.viewMode === 'dm' && r.currentConversationId) {
        const { sendDMMessage: n, uploadDMImage: a } =
          await Promise.resolve().then(() => (Le(), Yn));
        try {
          const o = [];
          if (r.pendingUploads.length > 0)
            for (const s of r.pendingUploads) {
              const i = await a({ name: s.fileName, blob: s.blob });
              i && o.push(i), URL.revokeObjectURL(s.preview);
            }
          await n(t, o);
        } catch (o) {
          d(o.message || 'Failed to send message', 'error');
        }
        return;
      }
      try {
        T.value = '';
        const n = `temp-${Date.now()}`,
          a = u.querySelector('.empty-state');
        a && a.remove();
        const o = { content: t };
        r.pendingUploads.length > 0 && (o.images = []);
        const s = await p(
          `/channels/${r.currentChannelId}/messages`,
          'POST',
          o
        );
        if (!s.message?.id) throw new Error('Failed to create message');
        const i = s.message.id;
        r.tempIdMap.set(n, i),
          r.messageCache.delete(n),
          r.messageCache.set(i, { ...s.message, content: s.message.content }),
          ta(n, i),
          r.pendingUploads.length > 0 &&
            (await Ra(i), await Yt(i, r.pendingUploads));
      } catch (n) {
        d(n.message || 'Failed to send message', 'error');
      }
    }
  }
  async function Ra(e) {
    try {
      L();
      const t = await M(),
        n = { 'Content-Type': 'application/json' };
      t && (n.Authorization = `Bearer ${t}`);
      const a = [],
        o = new Set();
      for (const s of r.pendingUploads) {
        if (o.has(s.fileHash)) {
          console.log(`Skipping duplicate image with hash: ${s.fileHash}`),
            URL.revokeObjectURL(s.preview);
          continue;
        }
        o.add(s.fileHash);
        const i = await Pt(s.blob),
          c = await p(
            `/channels/${r.currentChannelId}/messages/image`,
            'POST',
            { filename: s.fileName, image: i }
          ),
          { filename: m } = c;
        a.push(m), URL.revokeObjectURL(s.preview);
      }
      if (
        a.length > 0 &&
        (await p(`/messages/${e}`, 'PUT', { images: a }), r.messageCache.has(e))
      ) {
        const s = r.messageCache.get(e);
        (s.images = a), r.messageCache.set(e, s);
      }
      (r.pendingUploads = []),
        ae(),
        h(),
        a.length > 0 && d('Images uploaded successfully');
    } catch (t) {
      h(), d(t.message || 'Failed to upload images', 'error');
    }
  }
  async function st(e) {
    if (document.querySelector(`.message[data-id="${e.id}"]`)) return;
    if (!e.id.startsWith('temp-')) {
      const a = document.querySelectorAll('.message');
      for (const o of a) {
        const s = o.dataset.authorId === e.author.id,
          i = o.querySelector('.message-text')?.textContent === e.content,
          c = o.dataset.id.startsWith('temp-');
        if (s && i && c) {
          console.log(
            `Found matching temp message, updating ID from ${o.dataset.id} to ${e.id}`
          ),
            ta(o.dataset.id, e.id),
            r.messageCache.delete(o.dataset.id),
            r.messageCache.set(e.id, e),
            r.tempIdMap.set(o.dataset.id, e.id);
          return;
        }
      }
    }
    r.messageCache.set(e.id, e);
    const t = Tt(new Date(e.timestamp || e.createdAt));
    Fa(t);
    const n = document.createElement('div');
    (n.className = 'message'),
      (n.dataset.id = e.id),
      (n.dataset.authorId = e.author.id),
      (n.dataset.date = t),
      (n.innerHTML = Na(e)),
      Pa(e, n),
      u.prepend(n),
      await Ba(e),
      e.images && e.images.length > 0 && (await Yt(e.id, e.images));
  }
  async function Yt(e, t) {
    const n = document.querySelector(`.message[data-id="${e}"]`);
    if (n) {
      let a = n.querySelector('.message-images-container');
      if (!a) {
        const o = n.querySelector('.message-content');
        (a = document.createElement('div')),
          (a.className = 'message-images-container');
        const s = n.querySelector('.message-reactions');
        o.insertBefore(a, s);
      }
      for (const o of t) {
        const s = `${W}/channels/${r.currentChannelId}/messages/image/${o}`,
          i = `img-container-${e}-${o}`,
          c = document.createElement('div');
        (c.id = i),
          (c.className = 'message-image-container'),
          a.appendChild(c),
          await Qt(s, i, e, o);
      }
    }
  }
  function Na(e) {
    let t = 'Unknown User';
    e.author?.userName
      ? (t = e.author.userName)
      : e.author.id === r.currentUser.id && (t = r.currentUser.userName);
    let n = N(t),
      a = e.timestamp || e.createdAt,
      o = we(new Date(a)),
      s = '';
    if (e.content) {
      let i = We(e.content);
      (i = Xt(i)), (i = Zt(i)), (s = `<div class="message-text">${i}</div>`);
    }
    return `
  <div class="message-avatar">${n}</div>
  <div class="message-content">
    <div class="message-header">
      <span class="message-author">${t}</span>
      <span class="message-time">${o}</span>
    </div>
    ${s}
    <div class="message-images-container"></div>
    <div class="message-reactions"></div>
    <div class="message-actions">
      ${
        e.author.id === r.currentUser?.id
          ? `
        <button class="message-edit" data-id="${e.id}">Edit</button>
        <button class="message-delete" data-id="${e.id}">Delete</button>
      `
          : ''
      }
      <div class="add-reaction" data-id="${e.id}">+ Add Reaction</div>
    </div>
  </div>
`;
  }
  async function Ba(e) {
    if (e.reactions && Object.keys(e.reactions).length > 0) {
      const t = qt(e.reactions);
      for (const [n, a] of Object.entries(t)) {
        const o = a.includes(r.currentUser.id);
        await oe(e.id, n, a.length, o);
      }
    }
  }
  function Fa(e) {
    let t = !1,
      n = document.querySelectorAll('.message-date-divider');
    for (const a of n)
      if (a.textContent === e) {
        t = !0;
        break;
      }
    if (!t) {
      const a = document.createElement('div');
      (a.className = 'message-date-divider'), (a.textContent = e), u.prepend(a);
    }
  }
  function Pa(e, t) {
    const n = t.querySelector('.message-edit');
    n && n.addEventListener('click', () => Te(e));
    const a = t.querySelector('.message-delete');
    a && a.addEventListener('click', () => Oa(e.id));
    const o = t.querySelector('.add-reaction');
    o && o.addEventListener('click', () => ke(e.id));
  }
  async function Qn(e) {
    try {
      r.messageCache.clear(), (u.innerHTML = '');
      const { messages: t } = await p(`/channels/${e}/messages`);
      if (!t || t.length === 0) {
        ea();
        return;
      }
      const n = {};
      for (const s of t) {
        const i = Tt(new Date(s.createdAt));
        r.messageCache.set(s.id, s), n[i] || (n[i] = []), n[i].push(s);
      }
      const a = Object.keys(n).sort((s, i) => new Date(i) - new Date(s)),
        o = document.querySelectorAll('.message-date-divider');
      for (const s of a) {
        if (!Array.from(o).some((c) => c.textContent === s)) {
          const c = document.createElement('div');
          (c.className = 'message-date-divider'),
            (c.textContent = s),
            u.appendChild(c);
        }
        for (const c of n[s]) await st(c);
      }
    } catch (t) {
      console.error('Error loading messages:', t),
        d('Failed to load messages', 'error');
    }
  }
  function ea() {
    const e = u.querySelectorAll('.empty-state');
    for (const n of e) n.remove();
    const t = document.createElement('div');
    (t.className = 'empty-state'),
      (t.innerHTML = `
    <div class="empty-state-icon">\u{1F4AC}</div>
    <h3>No messages yet</h3>
    <p>Start the conversation!</p>
  `),
      u.appendChild(t);
  }
  function ta(e, t) {
    const n = document.querySelector(`.message[data-id="${e}"]`);
    if (n) {
      n.dataset.id = t;
      const a = n.querySelectorAll(`[data-id="${e}"]`);
      for (const s of a) s.dataset.id = t;
      const o = n.querySelectorAll(`[data-message-id="${e}"]`);
      for (const s of o) s.dataset.messageId = t;
    }
  }
  async function na(e, t) {
    const n = se(e);
    if (!n) {
      d('Invalid message ID', 'error');
      return;
    }
    try {
      if (
        (await p(`/messages/${n}`, 'PUT', { content: t }),
        r.messageCache.has(e))
      ) {
        const a = r.messageCache.get(e);
        r.messageCache.set(e, { ...a, content: t });
      }
      await Jt({ id: e, content: t }), d('Message updated successfully');
    } catch (a) {
      d(a.message || 'Failed to update message', 'error');
    }
  }
  async function Oa(e) {
    const t = se(e);
    if (!t) {
      d('Invalid message ID', 'error');
      return;
    }
    if (confirm('Are you sure you want to delete this message?'))
      try {
        await p(`/messages/${t}`, 'DELETE'),
          Kt(e),
          d('Message deleted successfully');
      } catch (n) {
        d(n.message || 'Failed to delete message', 'error');
      }
  }
  async function Jt(e) {
    const t = document.querySelector(`.message[data-id="${e.id}"]`);
    if (t) {
      const n = t.querySelector('.message-text');
      if (n) {
        let a = We(e.content);
        (a = Xt(a)), (a = Zt(a)), (n.innerHTML = a);
      }
      e.images && e.images.length > 0 && (await Yt(e.id, e.images));
    }
  }
  function Kt(e) {
    const t = document.querySelector(`.message[data-id="${e}"]`);
    if (t) {
      t.remove();
      const n = document.querySelectorAll('.message-date-divider');
      for (const a of n) {
        const o = a.nextElementSibling;
        (!o || o.classList.contains('message-date-divider')) && a.remove();
      }
      document.querySelector('.message') || ea();
    }
  }
  function Xt(e) {
    const t = /https?:\/\/[^\s]+/g;
    return e.replace(
      t,
      (n) => `<a href="${n}" target="_blank" class="message-link">${n}</a>`
    );
  }
  function Jn(e) {
    if (!e) return '';
    let t = We(e);
    return (t = Xt(t)), (t = Zt(t)), t;
  }
  function Kn(e) {
    return we(new Date(e));
  }
  function Zt(e) {
    const t = /#([a-zA-Z0-9_-]+)/g;
    return e.replace(t, (n, a) => {
      const s =
        Array.from(O.querySelectorAll('.channel-item')).find(
          (i) =>
            i.querySelector('.channel-name').textContent.toLowerCase() ===
            a.toLowerCase()
        )?.dataset.id || '';
      return s
        ? `<a href="#" class="channel-link" data-channel-id="${s}" data-channel-name="${a}">${n}</a>`
        : n;
    });
  }
  function se(e) {
    if (e?.startsWith('temp-')) {
      const t = r.tempIdMap.get(e);
      if (t) return t;
    }
    return e;
  }
  async function aa(e, t) {
    const n = `temp-${Date.now()}`,
      a = {
        id: n,
        content: t.content || '',
        author: r.currentUser,
        createdAt: new Date().toISOString(),
        reactions: {},
        images: [],
        isOffline: !0
      };
    return (
      r.messageCache.set(n, a),
      await st(a),
      d('Message saved locally. Will sync when online.', 'info'),
      { message: a }
    );
  }
  async function ra(e, t) {
    try {
      const n = se(e);
      if (!n) {
        d('Invalid message ID', 'error');
        return;
      }
      const a = r.messageCache.get(e);
      if (!a || !a.images) {
        d('Message data not found', 'error');
        return;
      }
      if (!a.author || a.author.id !== r.currentUser.id) {
        d("You don't have permission to remove this image", 'error');
        return;
      }
      const o = a.images.filter((i) => i !== t);
      await p(`/messages/${n}`, 'PUT', { images: o }),
        (a.images = o),
        r.messageCache.set(e, a);
      const s = document.getElementById(`img-container-${e}-${t}`);
      s && s.remove(), d('Image removed successfully');
    } catch (n) {
      d(n.message || 'Failed to remove image', 'error');
    }
  }
  var V = f(() => {
    v();
    I();
    U();
    w();
    y();
    D();
    B();
    xe();
    Se();
  });
  var ia = {};
  $(ia, {
    closeStartDmModalFn: () => dt,
    incrementDmUnread: () => an,
    loadConversations: () => it,
    openStartDmModal: () => tn,
    renderConversationItem: () => oa,
    renderConversationsList: () => ct,
    selectConversation: () => en,
    startConversation: () => sa,
    updateConversationInCache: () => nn
  });
  async function it() {
    try {
      const t = (await p('/conversations')).conversations || [];
      r.conversationCache.clear();
      for (const n of t) r.conversationCache.set(n.id, n);
      ct(t);
    } catch (e) {
      console.error('Failed to load conversations:', e);
    }
  }
  function ct(e) {
    if (ve) {
      if (((ve.innerHTML = ''), e.length === 0)) {
        ve.innerHTML = '<div class="empty-list">No conversations yet</div>';
        return;
      }
      for (const t of e) {
        const n = oa(t);
        ve.appendChild(n);
      }
    }
  }
  function oa(e) {
    const t = document.createElement('div');
    (t.className = 'dm-item'),
      (t.dataset.conversationId = e.id),
      r.currentConversationId === e.id && t.classList.add('active');
    const a = e.otherUser?.userName || 'Unknown User',
      o = a.charAt(0).toUpperCase();
    return (
      (t.innerHTML = `
    <div class="dm-avatar">${o}</div>
    <span class="dm-name">${a}</span>
    ${_a(e.id)}
  `),
      t.addEventListener('click', () => en(e.id)),
      t
    );
  }
  function _a(e) {
    const t = r.dmUnreadCounts.get(e) || 0;
    return t > 0
      ? `<div class="notification-badge">${t > 99 ? '99+' : t}</div>`
      : '';
  }
  async function en(e) {
    (r.currentChannelId = null),
      (r.viewMode = 'dm'),
      document
        .querySelectorAll('.channel-item')
        .forEach((a) => a.classList.remove('active')),
      document.querySelectorAll('.dm-item').forEach((a) => {
        a.classList.toggle('active', a.dataset.conversationId === e);
      }),
      (r.currentConversationId = e),
      r.dmUnreadCounts.set(e, 0);
    const t = r.conversationCache.get(e);
    if (t && b) {
      const a = t.otherUser?.userName || 'Direct Message';
      (b.textContent = a), b.style.setProperty('--channel-prefix', '"@"');
    }
    await zt(e);
    const n = document.getElementById('sidebar');
    n && n.classList.remove('open');
  }
  async function sa(e) {
    try {
      const t = await p('/conversations', 'POST', { targetUserId: e }),
        { conversation: n, isNew: a } = t;
      r.conversationCache.set(n.id, n),
        await it(),
        await en(n.id),
        dt(),
        a && d('Conversation started', 'success');
    } catch (t) {
      console.error('Failed to start conversation:', t),
        d(t.message || 'Failed to start conversation', 'error');
    }
  }
  async function tn() {
    if (!(!ye || !j)) {
      ye.classList.add('active');
      try {
        const n = ((await p('/users')).users || []).filter(
          (a) => a.id !== r.currentUser?.id
        );
        qa(n);
      } catch (e) {
        console.error('Failed to load users:', e),
          (j.innerHTML = '<div class="empty-list">Failed to load users</div>');
      }
    }
  }
  function dt() {
    ye && ye.classList.remove('active');
  }
  function qa(e) {
    if (j) {
      if (((j.innerHTML = ''), e.length === 0)) {
        j.innerHTML = '<div class="empty-list">No other users available</div>';
        return;
      }
      for (const t of e) {
        const n = document.createElement('div');
        n.className = 'dm-user-item';
        const a =
          t.userName?.charAt(0).toUpperCase() ||
          t.email.charAt(0).toUpperCase();
        (n.innerHTML = `
      <div class="user-avatar">${a}</div>
      <div class="user-info">
        <div class="user-name">${t.userName || t.email.split('@')[0]}</div>
        <div class="user-email">${t.email}</div>
      </div>
    `),
          n.addEventListener('click', () => sa(t.id)),
          j.appendChild(n);
      }
    }
  }
  function nn(e) {
    r.conversationCache.set(e.id, e);
    const t = Array.from(r.conversationCache.values());
    t.sort(
      (n, a) =>
        (a.lastMessageAt || a.createdAt) - (n.lastMessageAt || n.createdAt)
    ),
      ct(t);
  }
  function an(e) {
    if (r.currentConversationId === e) return;
    const t = r.dmUnreadCounts.get(e) || 0;
    r.dmUnreadCounts.set(e, t + 1);
    const n = Array.from(r.conversationCache.values());
    ct(n);
  }
  var lt = f(() => {
    v();
    I();
    y();
    Le();
    w();
  });
  async function Y(e) {
    r.messageEventSource &&
      (r.messageEventSource.close(), (r.messageEventSource = null)),
      Ue && (clearTimeout(Ue), (Ue = null));
    const t = await M();
    if (t)
      try {
        (r.messageEventSource = new EventSource(`${W}/events?token=${t}`)),
          (r.messageEventSource.onopen = function () {
            (ie = 0), (rn = 0);
          }),
          (r.messageEventSource.onmessage = async function (n) {
            try {
              const a = JSON.parse(n.data);
              switch (
                (console.log(`SSE event received: ${a.type}`, a.payload),
                a.type)
              ) {
                case 'CONNECTED':
                  break;
                case 'NEW_MESSAGE':
                  if (a.payload.channelId === r.currentChannelId)
                    await st(a.payload);
                  else {
                    const o = r.unreadCounts.get(a.payload.channelId) || 0;
                    r.unreadCounts.set(a.payload.channelId, o + 1);
                    const s = document.querySelector(
                      `.channel-item[data-id="${a.payload.channelId}"]`
                    );
                    if (s) {
                      const m = s.querySelector('.channel-name').textContent;
                      await de({ id: a.payload.channelId, name: m });
                    }
                    const i = a.payload.author?.userName || 'Someone',
                      c = s
                        ? s.querySelector('.channel-name').textContent
                        : 'another channel';
                    d(`${i} posted in #${c}`, 'info');
                  }
                  break;
                case 'UPDATE_MESSAGE':
                  a.payload.channelId === r.currentChannelId &&
                    (r.messageCache.has(a.payload.id) &&
                      r.messageCache.set(a.payload.id, {
                        ...r.messageCache.get(a.payload.id),
                        content: a.payload.content,
                        images: a.payload.images,
                        updatedAt: a.payload.updatedAt
                      }),
                    await Jt(a.payload));
                  break;
                case 'DELETE_MESSAGE':
                  a.payload.channelId === r.currentChannelId &&
                    (r.messageCache.delete(a.payload.id), Kt(a.payload.id));
                  break;
                case 'NEW_CHANNEL':
                  ce();
                  break;
                case 'NEW_REACTION':
                  if (a.payload.messageId) {
                    const o = a.payload.messageId,
                      s = a.payload.userId,
                      i = a.payload.reaction;
                    s !== r.currentUser.id && (await F(o, i, !0, !0));
                  }
                  break;
                case 'DELETE_REACTION':
                  if (a.payload.messageId) {
                    const o = a.payload.messageId,
                      s = a.payload.userId,
                      i = a.payload.reaction;
                    if (r.messageCache.has(o)) {
                      const c = r.messageCache.get(o);
                      c.reactions?.[i] &&
                        ((c.reactions[i] = c.reactions[i].filter(
                          (m) => m !== s
                        )),
                        c.reactions[i].length === 0 && delete c.reactions[i],
                        r.messageCache.set(o, c));
                    }
                    s !== r.currentUser.id && (await F(o, i, !1, !0));
                  }
                  break;
                case 'REMOVE_USER':
                  a.payload.id === r.currentUser.id && (await Ae());
                  break;
                case 'NEW_CONVERSATION':
                  await it();
                  break;
                case 'NEW_DM_MESSAGE':
                  if (a.payload.channelId.startsWith('dm:')) {
                    if (
                      r.viewMode === 'dm' &&
                      a.payload.channelId === r.currentConversationId
                    )
                      Wt(a.payload);
                    else {
                      an(a.payload.channelId);
                      const s = a.payload.author?.userName || 'Someone';
                      d(`${s} sent you a direct message`, 'info');
                    }
                    const o = r.conversationCache.get(a.payload.channelId);
                    o && ((o.lastMessageAt = a.payload.createdAt), nn(o));
                  }
                  break;
                case 'UPDATE_DM_MESSAGE':
                  a.payload.channelId.startsWith('dm:') && Gt(a.payload);
                  break;
                case 'DELETE_DM_MESSAGE':
                  a.payload.conversationId &&
                    Vt(a.payload.id, a.payload.conversationId);
                  break;
              }
            } catch (a) {
              console.error('Error processing SSE event', a);
            }
          }),
          (r.messageEventSource.onerror = function (n) {
            if (
              (rn < za && rn++,
              r.messageEventSource &&
                r.messageEventSource.readyState === EventSource.CLOSED)
            ) {
              r.messageEventSource.close(), (r.messageEventSource = null), ie++;
              const a = Math.min(1e3 * 2 ** ie, 30 * 1e3);
              ie <= Ha
                ? (console.log(`SSE reconnect attempt ${ie} in ${a}ms`),
                  (Ue = setTimeout(async () => {
                    await Y(e);
                  }, a)))
                : (console.log(
                    'Maximum SSE reconnect attempts reached, trying again in 60s'
                  ),
                  (ie = 0),
                  (Ue = setTimeout(async () => {
                    await Y(e);
                  }, 60 * 1e3)));
            }
          });
      } catch (n) {
        console.error('Error setting up SSE connection', n);
      }
  }
  var Ha,
    za,
    ie,
    Ue,
    rn,
    on = f(() => {
      v();
      U();
      D();
      y();
      V();
      Se();
      De();
      lt();
      Le();
      (Ha = 5), (za = 3), (ie = 0), (Ue = null), (rn = 0);
    });
  var ln = {};
  $(ln, {
    createChannel: () => sn,
    deleteChannel: () => cn,
    loadChannels: () => ce,
    restoreLastChannel: () => ja,
    selectChannel: () => le,
    updateChannelName: () => dn
  });
  async function ce() {
    try {
      const { channels: e } = await p('/channels');
      O.innerHTML = '';
      for (const t of e) await de(t);
      if (e.length > 0 && !r.currentChannelId) {
        const t = await r.storage.getItem('currentChannelId'),
          n = e.find((a) => a.id === t) || e[0];
        await le(n.id, n.name);
      }
      return e;
    } catch {
      d('Failed to load channels', 'error');
    }
  }
  async function le(e, t) {
    if (e === r.currentChannelId && r.viewMode === 'channel') return;
    (r.currentConversationId = null),
      (r.viewMode = 'channel'),
      document
        .querySelectorAll('.dm-item')
        .forEach((a) => a.classList.remove('active')),
      b.style.removeProperty('--channel-prefix'),
      (r.currentChannelId = e),
      (b.textContent = t),
      await r.storage.setItem('currentChannelId', e),
      r.unreadCounts.set(e, 0);
    const n = O.querySelectorAll('.channel-item');
    for (const a of n)
      if (a.dataset.id === e) {
        a.classList.add('active');
        const o = { id: e, name: t };
        a.querySelector('.channel-settings') &&
          (o.createdBy = r.currentUser.id),
          await de(o);
      } else a.classList.remove('active');
    await Qn(e), await Y(e);
  }
  async function sn(e) {
    try {
      const { channel: t } = await p('/channels', 'POST', { name: e });
      d(`Channel #${e} created successfully!`),
        await ce(),
        await le(t.id, t.name);
    } catch (t) {
      throw (d(t.message || 'Failed to create channel', 'error'), t);
    }
  }
  async function cn(e) {
    try {
      await p(`/channels/${e}`, 'DELETE'), d('Channel deleted successfully');
      const t = await ce();
      await le(t[0].id, t[0].name);
    } catch (t) {
      throw (d(t.message || 'Failed to delete channel', 'error'), t);
    }
  }
  async function dn(e, t) {
    try {
      const { channel: n } = await p(`/channels/${e}`, 'PUT', { name: t });
      return (
        d(`Channel renamed to #${t} successfully`),
        r.currentChannelId === e && (b.textContent = t),
        await ce(),
        n
      );
    } catch (n) {
      throw (d(n.message || 'Failed to update channel name', 'error'), n);
    }
  }
  async function ja() {
    const e = await r.storage.getItem('currentChannelId');
    if (!e) return;
    const t = document.querySelector(`.channel-item[data-id="${e}"]`);
    t && t.click();
  }
  var De = f(() => {
    v();
    I();
    w();
    y();
    V();
    on();
  });
  var be = {};
  $(be, {
    closeAllModals: () => pt,
    closeCreateChannelModal: () => mt,
    closeEditChannelModal: () => $e,
    closeEditModal: () => ut,
    closeReactionPicker: () => fn,
    getReactionCount: () => et,
    hideLoading: () => h,
    isReacted: () => ma,
    openCreateChannelModal: () => gn,
    openEditChannelModal: () => ua,
    openEditModal: () => Te,
    openReactionPicker: () => ke,
    reacted: () => tt,
    renderChannelItem: () => de,
    renderDevModeEncryptionSignInView: () => mn,
    renderDevModePlainSignInView: () => da,
    renderMagicLinkEncryptionSignInView: () => un,
    renderMagicLinkUnauthenticatedView: () => la,
    renderNewMagicLink: () => Wa,
    renderReaction: () => oe,
    scrollToBottom: () => ot,
    showAppScreen: () => pn,
    showAuthScreen: () => J,
    showLoading: () => L,
    showToast: () => d,
    signInWithMagicLink: () => ca,
    updatePendingUploadsUI: () => ae,
    updateReactionCount: () => re
  });
  async function J() {
    pt(), (ht.style.display = 'block'), (ft.style.display = 'none');
    const e = Re();
    if (!0) return P() || e ? mn() : da();
    if (!1) {
      if (G()) return P() ? un() : ca();
      if (e) {
        if (P()) return un();
        await Ie(R);
      }
      return la();
    }
  }
  function ca() {
    const { emailParam: e } = ne();
    (H.value = e), ee.click();
  }
  function da() {
    (pe.textContent = 'Enter your email to sign in.'),
      (ue.style.display = 'none'),
      h();
  }
  function mn() {
    (pe.textContent = 'Enter your email and encryption key to sign in.'),
      (ue.style.display = 'block'),
      h();
  }
  function un() {
    if (((pe.textContent = 'Enter your encryption key to sign in.'), G())) {
      (xn.getElementsByTagName('label')[0].style.display = 'none'),
        (H.style.display = 'none');
      const { emailParam: t } = ne();
      H.value = t;
    }
    (ue.style.display = 'block'), h();
  }
  function la() {
    (pe.textContent = 'Enter your email to get a magic link.'),
      (ue.style.display = 'none'),
      h();
  }
  async function Wa(e) {
    const { apiRequest: t } = await Promise.resolve().then(() => (w(), K)),
      n = await t('/auth/login', 'POST', { email: e });
    document.querySelector('.auth-form').style.display = 'none';
    const a = document.getElementById('magic-link-sent-form'),
      o = document.getElementById('magic-link-sent-message');
    (o.textContent =
      n.message ||
      `Magic link sent to ${e}. Please check your inbox and click the link to continue.`),
      (a.style.display = 'block');
  }
  async function pn() {
    const { loadServerName: e } = await Promise.resolve().then(
        () => (Bt(), qn)
      ),
      { loadChannels: t, restoreLastChannel: n } = await Promise.resolve().then(
        () => (De(), ln)
      ),
      { loadConversations: a } = await Promise.resolve().then(() => (lt(), ia));
    if (((r.currentUser = await pa()), !r.currentUser)) {
      h();
      return;
    }
    window.history.replaceState({}, document.title, window.location.pathname),
      await e(),
      await t(),
      await a(),
      (Dn.textContent = N(r.currentUser.userName)),
      ($n.textContent = r.currentUser.userName),
      (ht.style.display = 'none'),
      (ft.style.display = 'flex'),
      await n();
    const o = (await r.storage.getItem('darkMode')) !== 'false';
    await Ke(o), h();
  }
  async function de(e) {
    let { selectChannel: t } = await Promise.resolve().then(() => (De(), ln)),
      n = document.querySelector(`.channel-item[data-id="${e.id}"]`);
    n ||
      ((n = document.createElement('div')),
      (n.className = 'channel-item'),
      (n.dataset.id = e.id),
      n.addEventListener('click', async () => await t(e.id, e.name)),
      O.appendChild(n));
    const a = r.unreadCounts.get(e.id) || 0;
    n.innerHTML = '';
    const o = document.createElement('div');
    if (
      ((o.textContent = e.name),
      (o.className = 'channel-name'),
      n.appendChild(o),
      a > 0)
    ) {
      const s = document.createElement('div');
      (s.className = 'notification-badge'),
        (s.textContent = a > 99 ? '99+' : a),
        n.appendChild(s);
    }
    if (e.createdBy === r.currentUser.id) {
      const s = document.createElement('div');
      (s.className = 'channel-settings'),
        (s.innerHTML = '\u2699\uFE0F'),
        s.addEventListener('click', (i) => {
          i.stopPropagation(), ua(e);
        }),
        n.appendChild(s);
    }
    e.id === r.currentChannelId
      ? n.classList.add('active')
      : n.classList.remove('active');
  }
  function ae() {
    const { removePendingUpload: e } = Promise.resolve().then(() => (xe(), _t)),
      t = document.getElementById('pending-uploads-container'),
      n = document.getElementById('pending-uploads');
    if (r.pendingUploads.length === 0) {
      t.style.display = 'none';
      return;
    }
    (t.style.display = 'block'),
      (n.innerHTML = ''),
      r.pendingUploads.forEach((o, s) => {
        const i = document.createElement('div');
        (i.className = 'pending-upload'),
          (i.innerHTML = `
      <img src="${o.preview}" alt="Upload preview">
      <div class="remove-upload" data-index="${s}">&times;</div>
    `),
          n.appendChild(i);
      }),
      document.querySelectorAll('.remove-upload').forEach((o) => {
        o.addEventListener('click', async (s) => {
          const { removePendingUpload: i } = await Promise.resolve().then(
              () => (xe(), _t)
            ),
            c = Number.parseInt(s.target.dataset.index);
          i(c);
        });
      });
  }
  async function oe(e, t, n, a) {
    const { addReaction: o, removeReaction: s } = await Promise.resolve().then(
        () => (Se(), Wn)
      ),
      i = Ut(e);
    if (!i) return;
    const c = document.createElement('div');
    return (
      (c.className = `reaction ${a ? 'user-reacted' : ''}`),
      (c.dataset.reaction = t),
      (c.dataset.messageId = e),
      (c.innerHTML = `
        <span class="reaction-reaction">${t}</span>
        <span class="reaction-count">${n}</span>
      `),
      c.addEventListener('click', async () => {
        ma(c) ? await s(e, t) : await o(e, t);
      }),
      i.appendChild(c),
      c
    );
  }
  function et(e) {
    if (!e) return 0;
    const t = e.querySelector('.reaction-count');
    if (t) return Number.parseInt(t.textContent, 10) || 0;
  }
  function re(e, t) {
    if (!e) return;
    const n = e.querySelector('.reaction-count');
    n && (n.textContent = t.toString());
  }
  function tt(e, t) {
    e && (e.className = `reaction ${t ? 'user-reacted' : ''}`);
  }
  function ma(e) {
    if (e) return Array.from(e.classList).includes('user-reacted');
  }
  function d(e, t = 'success') {
    (he.textContent = e),
      (he.className = `toast ${t}`),
      he.classList.add('show'),
      setTimeout(() => {
        he.classList.remove('show');
      }, 3e3);
  }
  function ot() {
    const e = document.getElementById('messages-area');
    e && (e.scrollTop = 0);
  }
  function L() {
    Mt.style.display = 'flex';
  }
  function h() {
    Mt.style.display = 'none';
  }
  function gn() {
    vt.classList.add('active'), Q.focus();
  }
  function mt() {
    vt.classList.remove('active'), (Q.value = '');
  }
  function ke(e) {
    (r.currentMessageForReaction = e), me.classList.add('active');
  }
  function fn() {
    me.classList.remove('active'), (r.currentMessageForReaction = null);
  }
  function Te(e) {
    (r.currentMessageForEdit = e.id),
      (q.value = e.content),
      wt.classList.add('active'),
      q.focus();
  }
  function ut() {
    wt.classList.remove('active'),
      (q.value = ''),
      (r.currentMessageForEdit = null);
  }
  function ua(e) {
    (r.currentChannelForEdit = e),
      (_.value = e.name),
      Et.classList.add('active'),
      _.focus();
  }
  function $e() {
    Et.classList.remove('active'),
      (_.value = ''),
      (r.currentChannelForEdit = null);
  }
  function pt() {
    document
      .querySelectorAll('.modal-backdrop.active')
      .forEach((t) => t.classList.remove('active')),
      (r.currentMessageForReaction = null),
      (r.currentMessageForEdit = null),
      (r.currentChannelForEdit = null);
  }
  var y = f(() => {
    v();
    I();
    U();
    At();
    Je();
    D();
    Ye();
    B();
    $t();
  });
  var K = {};
  $(K, { apiRequest: () => p, fetchImageWithAuth: () => Qt });
  async function p(e, t = 'GET', n = null, a = null) {
    if (!navigator.onLine && t !== 'GET') {
      if (e.includes('/channels/') && e.includes('/messages') && t === 'POST')
        return aa(e, n);
      throw (
        (d(
          "You're offline. This action will be available when you reconnect.",
          'error'
        ),
        new Error('Offline - cannot perform this action'))
      );
    }
    if (!1)
      try {
        if (await ga()) {
          await fa();
          const c = await M();
          c && (await r.storage.setItem('accessToken', c));
        }
      } catch (c) {
        throw (
          (console.error('Token refresh failed:', c),
          await r.storage.removeItem('accessToken'),
          (r.currentUser = null),
          await J(),
          d('Session expired. Please log in again.', 'error'),
          new Error('Authentication failed'))
        );
      }
    let o = { 'Content-Type': 'application/json' },
      s = a;
    r.isStorageInitialized && (s = a || (await M())),
      s && (o.Authorization = `Bearer ${s}`);
    const i = { method: t, headers: o };
    n && (i.body = JSON.stringify(n));
    try {
      const c = await fetch(`${W}${e}`, i);
      if (!c.ok) {
        let l = `Error ${c.status}: ${c.statusText}`;
        try {
          l =
            (
              await c
                .clone()
                .json()
                .catch(() => ({}))
            ).error || l;
        } catch (g) {
          console.error('Could not parse error response', g);
        }
        throw new Error(l);
      }
      if (t === 'DELETE' || c.headers.get('content-length') === '0')
        return { success: !0 };
      if (e === '/events') return c;
      if (c.headers.get('content-type')?.includes('application/json'))
        try {
          return await c.clone().json();
        } catch (l) {
          console.error('JSON parsing error:', l, 'for endpoint:', e);
          const g = await c.text();
          try {
            return g ? JSON.parse(g) : { success: !0 };
          } catch (E) {
            return (
              console.error('Manual JSON parsing also failed:', E),
              { success: !0, text: g }
            );
          }
        }
      else {
        const l = await c.text();
        if (!l) return { success: !0 };
        try {
          return JSON.parse(l);
        } catch {
          return { success: !0, text: l };
        }
      }
    } catch (c) {
      throw (
        (navigator.onLine
          ? d(c.message, 'error')
          : d("You're working offline. Some features may be limited.", 'info'),
        c)
      );
    }
  }
  async function Qt(e, t, n, a) {
    const o = await M();
    await fetch(e, { method: 'GET', headers: { Authorization: `Bearer ${o}` } })
      .then((s) => {
        if (!s.ok) throw new Error('Image fetch failed');
        return s.blob();
      })
      .then((s) => {
        const i = URL.createObjectURL(s),
          c = document.getElementById(t);
        if (c) {
          c.innerHTML = '';
          const m = document.createElement('div');
          m.className = 'image-wrapper';
          const l = document.createElement('img');
          (l.src = i),
            (l.alt = 'User uploaded image'),
            (l.className = 'message-image'),
            l.setAttribute('onclick', `openImagePreview('${e}')`),
            m.appendChild(l);
          const g = r.messageCache.get(n);
          if (g?.author && g.author.id === r.currentUser.id) {
            const C = document.createElement('div');
            (C.className = 'remove-image-btn'),
              (C.innerHTML = '&times;'),
              (C.onclick = function (X) {
                X.stopPropagation(), confirm('Remove this image?') && ra(n, a);
              }),
              m.appendChild(C);
          }
          c.appendChild(m);
        }
      })
      .catch((s) => {
        console.error('Error fetching image:', s);
        const i = document.getElementById(t);
        i &&
          (i.innerHTML = '<div class="image-error">Failed to load image</div>');
      });
  }
  var w = f(() => {
    v();
    U();
    y();
    D();
    y();
    V();
  });
  async function va(e) {
    try {
      return (
        await r.storage.setItem('accessToken', e.accessToken),
        await r.storage.setItem('refreshToken', e.refreshToken),
        await r.storage.setItem('exp', Date.now() + e.exp * 1e3),
        !0
      );
    } catch (t) {
      return console.error('Failed to save tokens:', t), !1;
    }
  }
  async function ya() {
    try {
      return { accessToken: await M(), refreshToken: await Ea() };
    } catch (e) {
      return console.error('Failed to get tokens:', e), null;
    }
  }
  async function M() {
    return (
      (await r.storage.getItem('token')) ||
      (await r.storage.getItem('accessToken'))
    );
  }
  async function Ea() {
    return await r.storage.getItem('refreshToken');
  }
  async function Ga() {
    try {
      return (
        await r.storage.removeItem('accessToken'),
        await r.storage.removeItem('refreshToken'),
        !0
      );
    } catch (e) {
      return console.error('Failed to clear tokens:', e), !1;
    }
  }
  async function ga() {
    const e = await ya();
    return e ? Date.now() > e.exp - 10 * 1e3 : !0;
  }
  function Va(e) {
    if (!e) return null;
    try {
      const n = e.split('.')[1].replace(/-/g, '+').replace(/_/g, '/'),
        a = decodeURIComponent(
          atob(n)
            .split('')
            .map((o) => `%${`00${o.charCodeAt(0).toString(16)}`.slice(-2)}`)
            .join('')
        );
      return JSON.parse(a);
    } catch (t) {
      return console.error('Failed to parse token:', t), null;
    }
  }
  async function pa() {
    const { apiRequest: e } = await Promise.resolve().then(() => (w(), K)),
      t = await M();
    if (!t) return;
    const { user: n } = await e('/auth/me', 'GET');
    if (!n) return;
    const a = Va(t);
    if (a)
      return {
        id: n.id,
        userName: n.userName,
        email: n.sub,
        isAdmin: n.isAdmin,
        lastLogin: a.lastLogin,
        metadata: a.metadata
      };
  }
  async function On(e) {
    const { apiRequest: t } = await Promise.resolve().then(() => (w(), K));
    try {
      const n = await t('/auth/verify', 'POST', { email: e.email }, e.token);
      return await va(n), n;
    } catch (n) {
      return console.error('Error while verifying token:', n), !1;
    }
  }
  async function fa() {
    const { apiRequest: e } = await Promise.resolve().then(() => (w(), K)),
      t = await Ea();
    if (!t) throw new Error('No refresh token available');
    try {
      const n = await e('/auth/refresh', 'POST', { refreshToken: t });
      if (!n.ok) throw new Error('Failed to refresh token');
      return await va(n), n;
    } catch (n) {
      throw (await Ga(), n);
    }
  }
  async function Ae() {
    const { apiRequest: e } = await Promise.resolve().then(() => (w(), K)),
      { accessToken: t, refreshToken: n } = await ya();
    if (!t || !n) {
      ha();
      return;
    }
    await e('/auth/logout', 'POST', { refreshToken: n }).then((a) => {
      if (a.error) throw new Error('Failed to logout');
      ha();
    });
  }
  async function ha() {
    const { showToast: e } = await Promise.resolve().then(() => (y(), be));
    localStorage.clear(),
      r.storage.clear(),
      (r.storage = null),
      (r.currentUser = null),
      r.messageEventSource &&
        (r.messageEventSource.close(), (r.messageEventSource = null)),
      (r.tempIdMap = new Map()),
      (r.messageCache = new Map()),
      (r.unreadCounts = new Map()),
      (window.location = '/'),
      e('You have been signed out');
  }
  function P() {
    return !1;
  }
  function Re() {
    return Dt();
  }
  async function wa(e, t) {
    const {
      showToast: n,
      showLoading: a,
      hideLoading: o,
      showAppScreen: s,
      renderNewMagicLink: i
    } = await Promise.resolve().then(() => (y(), be));
    if (!e || !e.trim()) {
      n('Please enter your email', 'error');
      return;
    }
    if (!Nn(e)) {
      n('Email appears invalid. Please check the input.', 'error');
      return;
    }
    if (z.style.display === 'block' && P() && (!t || !t.trim())) {
      n('Please enter your encryption password', 'error');
      return;
    }
    try {
      if ((a(), !(await Ce(R)))) {
        o(), n('Invalid encryption key', 'error');
        return;
      }
      if ((P() || (z.value = R), !0)) return await Ya(e);
      if (!1) {
        if (G()) return await Ja();
        if (Re()) {
          if (await Fn(t)) return n('Successfully logged in!'), await s();
          n('Invalid password', 'error');
        } else await i(e);
      }
      o();
    } catch (c) {
      o(), n(c.message || 'Failed to log in', 'error');
    }
  }
  async function Ya(e) {
    const { apiRequest: t } = await Promise.resolve().then(() => (w(), K)),
      { showToast: n, showAppScreen: a } = await Promise.resolve().then(
        () => (y(), be)
      ),
      o = await t('/auth/dev-login', 'POST', { email: e });
    return (
      await r.storage.setItem('token', o.token),
      (r.currentUser = o.user),
      n('Successfully logged in!'),
      await a()
    );
  }
  async function Ja() {
    const { showToast: e, showAppScreen: t } = await Promise.resolve().then(
      () => (y(), be)
    );
    return await Pn(), e('Successfully logged in!'), await t();
  }
  var D = f(() => {
    v();
    I();
    U();
    B();
    Ye();
    Je();
  });
  v();
  I();
  D();
  V();
  De();
  Se();
  xe();
  $t();
  U();
  D();
  Ye();
  Je();
  y();
  async function Ia() {
    try {
      return (
        L(),
        G() && !0 && (window.location = '/'),
        P() ? await J() : Re() ? (await Ce(), await pn()) : await J()
      );
    } catch (e) {
      return (
        console.error('Error while checking if authenticated:', e),
        d('Failed to initialize the application', 'error'),
        h(),
        await J()
      );
    }
  }
  on();
  bt();
  Bt();
  y();
  w();
  lt();
  Le();
  B();
  function Ma() {
    (window.openImagePreview = Ot),
      window.addEventListener('online', async () => {
        r.currentChannelId && (await Y(r.currentChannelId));
      }),
      window.addEventListener('DOMContentLoaded', async () => {
        await Ia();
      }),
      document.addEventListener('click', () => {
        kt.classList.remove('show');
      }),
      document.addEventListener('keydown', (e) => {
        e.key === 'Escape' && pt();
      }),
      document.addEventListener('keydown', (e) => {
        e.key === 'Escape' &&
          k.classList.contains('active') &&
          k.classList.remove('active');
      }),
      document.addEventListener('click', (e) => {
        window.innerWidth <= 768 &&
          He.classList.contains('open') &&
          !e.target.closest('.sidebar') &&
          !e.target.closest('.menu-toggle') &&
          He.classList.remove('open');
      }),
      document.addEventListener('visibilitychange', () => {
        document.visibilityState === 'hidden'
          ? r.messageEventSource &&
            (r.messageEventSource.close(), (r.messageEventSource = null))
          : document.visibilityState === 'visible' &&
            !r.messageEventSource &&
            r.currentChannelId &&
            Y(r.currentChannelId);
      }),
      ee?.addEventListener('click', () => {
        const e = H.value.trim(),
          t = z ? z.value?.trim() : null;
        wa(e, t);
      }),
      Tn?.addEventListener('click', () => Ae()),
      H?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && (e.preventDefault(), ee.click());
      }),
      z?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && (e.preventDefault(), ee.click());
      }),
      Ct?.addEventListener('click', () => {
        const e = T.value;
        Zn(e);
      }),
      T?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), Ct.click());
      }),
      hn?.addEventListener('click', () => gn()),
      yt?.addEventListener('click', async () => {
        const e = Q.value.trim();
        e && (await sn(e), mt());
      }),
      Q?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && (e.preventDefault(), yt.click());
      }),
      vn?.addEventListener('click', () => mt()),
      Cn?.addEventListener('click', async () => {
        r.currentChannelForEdit &&
          confirm('Are you sure you want to delete this channel?') &&
          (await cn(r.currentChannelForEdit.id), $e());
      }),
      St?.addEventListener('click', async () => {
        const e = _.value.trim();
        e &&
          r.currentChannelForEdit &&
          (await dn(r.currentChannelForEdit.id, e), $e());
      }),
      _?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && (e.preventDefault(), St.click());
      }),
      yn?.addEventListener('click', () => $e()),
      It?.addEventListener('click', async () => {
        const e = q.value.trim();
        e &&
          r.currentMessageForEdit &&
          (r.currentMessageForEditIsDM
            ? (await rt(
                r.currentMessageForEdit,
                e,
                r.currentMessageForEditImages || []
              ),
              (r.currentMessageForEditIsDM = !1),
              (r.currentMessageForEditImages = []))
            : await na(r.currentMessageForEdit, e),
          ut());
      }),
      q?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), It.click());
      }),
      En?.addEventListener('click', () => ut()),
      Sn?.addEventListener('click', async (e) => {
        const t = e.target.closest('.reaction-item');
        if (t && r.currentMessageForReaction) {
          const n = t.dataset.reaction;
          await nt(r.currentMessageForReaction, n);
        }
      }),
      wn?.addEventListener('click', () => fn()),
      kn?.addEventListener('change', (e) => {
        e.target.files.length > 0 &&
          (Qe(e.target.files), (e.target.value = ''));
      }),
      In?.addEventListener('click', () => {
        k.classList.remove('active');
        const e = x.getAttribute('data-object-url');
        e && (URL.revokeObjectURL(e), x.removeAttribute('data-object-url'));
      }),
      u?.addEventListener('dragover', (e) => {
        e.preventDefault(), u.classList.add('drag-over');
      }),
      u?.addEventListener('dragleave', () => {
        u.classList.remove('drag-over');
      }),
      u?.addEventListener('drop', (e) => {
        e.preventDefault(),
          u.classList.remove('drag-over'),
          e.dataTransfer.files.length > 0 && Qe(e.dataTransfer.files);
      }),
      u?.addEventListener('click', async (e) => {
        const t = e.target.closest('.channel-link');
        if (t) {
          e.preventDefault();
          const c = t.dataset.channelId,
            m = t.dataset.channelName;
          c && (await le(c, m));
          return;
        }
        const n = e.target.closest('.message-edit[data-is-dm="true"]');
        if (n) {
          const c = n.dataset.messageId,
            m = e.target.closest('.message'),
            l = m?.querySelector('.message-text')?.textContent || '',
            g = [];
          m?.querySelectorAll('.message-image').forEach((E) => {
            E.dataset.image && g.push(E.dataset.image);
          }),
            (r.currentMessageForEdit = c),
            (r.currentMessageForEditIsDM = !0),
            (r.currentMessageForEditContent = l),
            (r.currentMessageForEditImages = g),
            Te({ id: c, content: l, images: g });
          return;
        }
        const a = e.target.closest('.message-delete[data-is-dm="true"]');
        if (a) {
          const c = a.dataset.messageId;
          confirm('Are you sure you want to delete this message?') &&
            (await jt(c));
          return;
        }
        const o = e.target.closest('.add-reaction[data-message-id]');
        if (o) {
          const c = o.dataset.messageId;
          (r.currentMessageForReaction = c),
            (r.currentMessageForReactionIsDM = !0),
            ke(c);
          return;
        }
        const s = e.target.closest('.reaction[data-message-id]');
        if (s) {
          const c = s.dataset.messageId,
            m = s.dataset.reaction;
          (r.currentMessageForReactionIsDM = !0),
            Ge(c, m) ? await Ht(c, m) : await nt(c, m);
          return;
        }
        const i = e.target.closest('.remove-image-btn[data-message-id]');
        if (i) {
          e.stopPropagation();
          const c = i.dataset.messageId,
            m = i.dataset.image;
          if (confirm('Remove this image?')) {
            const l = e.target.closest('.message'),
              g = [];
            l?.querySelectorAll('.message-image').forEach((C) => {
              C.dataset.image &&
                C.dataset.image !== m &&
                g.push(C.dataset.image);
            });
            const E = l?.querySelector('.message-text')?.textContent || '';
            await rt(c, E, g);
          }
          return;
        }
      }),
      ze?.addEventListener('click', async () => {
        const e = !document.body.classList.contains('light-mode');
        await Ke(!e);
      }),
      Un?.addEventListener('click', () => {
        He.classList.toggle('open');
      }),
      An?.addEventListener('click', (e) => {
        e.stopPropagation(), kt.classList.toggle('show');
      }),
      _e?.addEventListener('click', () => Rt()),
      Mn?.addEventListener('click', () => Ze()),
      Lt?.addEventListener('click', async () => {
        const e = te.value.trim();
        e && (await Nt(e));
      }),
      te?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && (e.preventDefault(), Lt.click());
      }),
      gt?.addEventListener('click', async () => {
        const e = Oe.value.trim();
        e && (await _n(e, 'user'), (Oe.value = ''));
      }),
      Oe?.addEventListener('keydown', (e) => {
        e.key === 'Enter' && (e.preventDefault(), gt.click());
      }),
      Ln?.addEventListener('click', async () => {
        if (confirm('Are you sure you want to leave this server?'))
          try {
            await p('/users/exit', 'POST'), await Ae();
          } catch (e) {
            console.error('Error exiting server:', e);
          }
      }),
      bn?.addEventListener('click', () => tn()),
      Rn?.addEventListener('click', () => dt());
  }
  Ma();
})();
